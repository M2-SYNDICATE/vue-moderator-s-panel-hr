import axios, {
  type AxiosInstance,
  type AxiosRequestConfig,
  type AxiosResponse,
  AxiosError,
} from 'axios'
import { authManager } from '@/utils/auth'
import router from '@/router'

// ===================== –¢–∏–ø—ã =====================

interface ApiResponse<T = any> {
  data: T
  message?: string
  success: boolean
  errors?: Record<string, string[]>
}

interface PaginatedResponse<T = any> {
  data: T[]
  meta: {
    current_page: number
    last_page: number
    per_page: number
    total: number
  }
  links: {
    first: string
    last: string
    prev: string | null
    next: string | null
  }
}

interface QueueItem {
  resolve: (value: any) => void
  reject: (error: any) => void
}

// –¢–∏–ø—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º
export interface LoginCredentials {
  email: string
  password: string
}

export interface Vacancy {
  id: number
  title: string
  // –¥–æ–±–∞–≤—å—Ç–µ –¥—Ä—É–≥–∏–µ –ø–æ–ª—è, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å –≤ –æ—Ç–≤–µ—Ç–µ –±—ç–∫–µ–Ω–¥–∞
}

export interface Candidate {
  id: number
  fullName: string
  vacancyId: number
  resumeAnalysis: 'suitable' | 'not_suitable' | 'analyzing'
  callStatus: 'not_planned' | 'planned' | 'in_progress' | 'completed'
  comments?: string
  callDate?: string
  callLink?: string
}

// ===================== API Client =====================

class ApiClient {
  private client: AxiosInstance
  private isRefreshing = false
  private failedQueue: QueueItem[] = []

  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      withCredentials: false,
    })

    this.setupInterceptors()
  }

  private setupInterceptors(): void {
    // Request interceptor - –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –∫ –∫–∞–∂–¥–æ–º—É –∑–∞–ø—Ä–æ—Å—É
    this.client.interceptors.request.use(
      (config) => {
        const token = authManager.getAccessToken()
        if (token && authManager.isTokenValid()) {
          // –î–æ–±–∞–≤–ª—è–µ–º Bearer —Ç–æ–∫–µ–Ω –≤ –∑–∞–≥–æ–ª–æ–≤–æ–∫ Authorization (–∏–º–µ–Ω–Ω–æ —Ç–∞–∫, –∫–∞–∫ –æ–∂–∏–¥–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä)
          config.headers.Authorization = `Bearer ${token}`
        }

        // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏
        config.headers['Accept'] = 'application/json'

        // Content-Type —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ FormData
        if (!(config.data instanceof FormData)) {
          config.headers['Content-Type'] = 'application/json'
        }

        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ (–º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ)
        console.log('üöÄ Request:', {
          method: config.method?.toUpperCase(),
          url: `${config.baseURL}${config.url}`,
          headers: {
            Authorization: config.headers.Authorization ? 'Bearer ***' : 'Not set',
            'Content-Type': config.headers['Content-Type'],
            Accept: config.headers['Accept'],
          },
        })

        return config
      },
      (error) => {
        console.error('‚ùå Request interceptor error:', error)
        return Promise.reject(error)
      },
    )

    // Response interceptor - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
        console.log('‚úÖ Response:', {
          status: response.status,
          url: response.config.url,
          data: response.data,
        })
        return response
      },
      async (error: AxiosError) => {
        const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean }

        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫
        console.error('‚ùå Response error:', {
          status: error.response?.status,
          url: error.config?.url,
          message: error.response?.data || error.message,
        })

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º 401 –æ—à–∏–±–∫–∏ (Unauthorized)
        if (error.response?.status === 401 && !originalRequest._retry) {
          console.log('üîÑ Token expired, trying to refresh...')

          if (this.isRefreshing) {
            // –ï—Å–ª–∏ —É–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –≤ –æ—á–µ—Ä–µ–¥—å
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject })
            })
              .then((token) => {
                if (originalRequest.headers) {
                  originalRequest.headers.Authorization = `Bearer ${token}`
                }
                return this.client(originalRequest)
              })
              .catch((err) => {
                return Promise.reject(err)
              })
          }

          originalRequest._retry = true
          this.isRefreshing = true

          try {
            const newToken = await this.refreshToken()
            this.processQueue(null, newToken)

            if (originalRequest.headers) {
              originalRequest.headers.Authorization = `Bearer ${newToken}`
            }

            console.log('‚úÖ Token refreshed successfully')
            return this.client(originalRequest)
          } catch (refreshError) {
            console.error('‚ùå Token refresh failed:', refreshError)
            this.processQueue(refreshError, null)
            this.handleAuthError()
            return Promise.reject(refreshError)
          } finally {
            this.isRefreshing = false
          }
        }

        return Promise.reject(error)
      },
    )
  }

  private async refreshToken(): Promise<string> {
    const refreshToken = authManager.getRefreshToken()

    if (!refreshToken) {
      throw new Error('Refresh token –Ω–µ –Ω–∞–π–¥–µ–Ω')
    }

    try {
      // –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π axios instance –¥–ª—è refresh –∑–∞–ø—Ä–æ—Å–∞
      const refreshClient = axios.create({
        baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      })

      console.log('üîÑ Refreshing token...')

      const response = await refreshClient.post('/refresh', {
        refresh_token: refreshToken,
      })

      const tokenData = response.data?.data || response.data

      if (!tokenData?.access_token) {
        throw new Error('Invalid refresh response')
      }

      authManager.setTokens({
        access_token: tokenData.access_token,
        refresh_token: tokenData.refresh_token || refreshToken,
        expires_in: tokenData.expires_in || 3600,
        token_type: tokenData.token_type || 'Bearer',
      })

      return tokenData.access_token
    } catch (error) {
      console.error('‚ùå Token refresh failed:', error)
      authManager.clearTokens()
      throw error
    }
  }

  private processQueue(error: any, token: string | null): void {
    this.failedQueue.forEach(({ resolve, reject }) => {
      if (error) {
        reject(error)
      } else {
        resolve(token)
      }
    })

    this.failedQueue = []
  }

  private handleAuthError(): void {
    authManager.clearTokens()

    // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤—Ö–æ–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –Ω–∞—Ö–æ–¥–∏–º—Å—è —É–∂–µ —Ç–∞–º
    if (router.currentRoute.value.name !== 'login') {
      router.push({ name: 'login' })
    }
  }

  // –ë–∞–∑–æ–≤—ã–µ HTTP –º–µ—Ç–æ–¥—ã
  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {
    return await this.client.get<T>(url, config)
  }

  async post<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): Promise<AxiosResponse<T>> {
    return await this.client.post<T>(url, data, config)
  }

  async put<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): Promise<AxiosResponse<T>> {
    return await this.client.put<T>(url, data, config)
  }

  async patch<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): Promise<AxiosResponse<T>> {
    return await this.client.patch<T>(url, data, config)
  }

  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {
    return await this.client.delete<T>(url, config)
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ axios –¥–ª—è –ø—Ä—è–º–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
  getAxiosInstance(): AxiosInstance {
    return this.client
  }
}

// –°–æ–∑–¥–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä API –∫–ª–∏–µ–Ω—Ç–∞
export const apiClient = new ApiClient()

// –ü–æ–ª—É—á–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä axios –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
const api = apiClient.getAxiosInstance()

// ===================== API –ú–µ—Ç–æ–¥—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ =====================

// Login
export const login = async (credentials: LoginCredentials): Promise<AxiosResponse<any>> => {
  return await api.post('/login', credentials)
}

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤–∞–∫–∞–Ω—Å–∏–π
export const getVacancies = async (): Promise<AxiosResponse<Vacancy[]>> => {
  return await api.get('/vacancies')
}

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
export const getCandidates = async (): Promise<AxiosResponse<Candidate[]>> => {
  return await api.get('/candidates')
}

// –ü–æ–ª—É—á–∏—Ç—å –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –ø–æ ID
export const getCandidateById = async (candidateId: number): Promise<AxiosResponse<Candidate>> => {
  return await api.get(`/candidate/${candidateId}`)
}

// –£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –ø–æ ID
export const deleteCandidate = async (candidateId: number): Promise<void> => {
  await api.delete(`/candidate/${candidateId}`)
}

// –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –≤–∞–∫–∞–Ω—Å–∏–∏
export const uploadVacancyFile = async (file: File): Promise<AxiosResponse<any>> => {
  const formData = new FormData()
  formData.append('info_cv', file)

  try {
    const response = await api.post('/vacancy', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      transformResponse: (data) => {
        try {
          return JSON.parse(data)
        } catch {
          return data
        }
      },
    })
    return response
  } catch (error) {
    if (error instanceof AxiosError && error.response) {
      try {
        const text = await error.response.data.text?.()
        if (text) error.response.data = text
      } catch {}
    }
    throw error
  }
}

// –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
export const addCandidate = async (
  vacancyId: number,
  resumeFiles: File | File[],
): Promise<AxiosResponse<any>> => {
  const formData = new FormData()

  // –î–æ–±–∞–≤–ª—è–µ–º vacancy_id
  formData.append('vacancy_id', vacancyId.toString())

  // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∫–∞–∫ –æ–¥–∏–Ω —Ñ–∞–π–ª, —Ç–∞–∫ –∏ –º–∞—Å—Å–∏–≤
  const files = Array.isArray(resumeFiles) ? resumeFiles : [resumeFiles]
  files.forEach((file) => {
    formData.append('resumes', file) // ‚Üê –∏–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 'resumes' (–∫–∞–∫ –≤ –±—ç–∫–µ–Ω–¥–µ)
  })

  try {
    const response = await api.post('/candidate', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
    return response
  } catch (error) {
    if (error instanceof AxiosError && error.response?.data) {
      try {
        const text = await error.response.data.text?.()
        if (text) error.response.data = text
      } catch (e) {
        console.warn('Could not parse error response as text')
      }
    }
    throw error
  }
}

// –£–¥–∞–ª–∏—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é –ø–æ ID
export const deleteVacancy = async (vacancyId: number): Promise<void> => {
  await api.delete(`/vacancy/${vacancyId}`)
}

// –°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª –≤–∞–∫–∞–Ω—Å–∏–∏
export const downloadVacancyFile = async (vacancyId: number): Promise<void> => {
  const response = await api.get(`/download/vacancy/${vacancyId}`, {
    responseType: 'blob',
  })

  let filename = `vacancy_${vacancyId}`

  const contentDisposition = response.headers['content-disposition']
  const extractedFilename = getFilenameFromContentDisposition(contentDisposition)

  if (extractedFilename) {
    filename = extractedFilename
  } else {
    const contentType = response.headers['content-type']

    if (contentType) {
      if (contentType.includes('word') || contentType.includes('msword')) {
        filename += '.doc'
      } else if (contentType.includes('openxmlformats-officedocument.wordprocessingml.document')) {
        filename += '.docx'
      } else if (contentType.includes('pdf')) {
        filename += '.pdf'
      } else if (contentType.includes('font/ttf') || contentType.includes('font-truetype')) {
        filename += '.ttf'
      } else if (contentType.includes('font/woff')) {
        filename += '.woff'
      } else if (contentType.includes('font/woff2')) {
        filename += '.woff2'
      } else if (contentType.includes('font/otf')) {
        filename += '.otf'
      } else if (contentType.includes('font/')) {
        filename += '.font'
      } else {
        filename += '.bin'
      }
    } else {
      filename += '.bin'
    }
  }

  const url = window.URL.createObjectURL(new Blob([response.data]))
  const link = document.createElement('a')
  link.href = url
  link.setAttribute('download', filename)
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  window.URL.revokeObjectURL(url)
}

// –°–∫–∞—á–∞—Ç—å —Ä–µ–∑—é–º–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
export const downloadCandidateResume = async (candidateId: number): Promise<void> => {
  const response = await api.get(`/download/candidate/${candidateId}`, {
    responseType: 'blob',
  })

  let filename = `resume_${candidateId}`

  const contentDisposition = response.headers['content-disposition']
  const extractedFilename = getFilenameFromContentDisposition(contentDisposition)

  if (extractedFilename) {
    filename = extractedFilename
  } else {
    const contentType = response.headers['content-type']

    if (contentType) {
      if (contentType.includes('word') || contentType.includes('msword')) {
        filename += '.doc'
      } else if (contentType.includes('openxmlformats-officedocument.wordprocessingml.document')) {
        filename += '.docx'
      } else if (contentType.includes('pdf')) {
        filename += '.pdf'
      } else if (contentType.includes('font/ttf') || contentType.includes('font-truetype')) {
        filename += '.ttf'
      } else if (contentType.includes('font/woff')) {
        filename += '.woff'
      } else if (contentType.includes('font/woff2')) {
        filename += '.woff2'
      } else if (contentType.includes('font/otf')) {
        filename += '.otf'
      } else if (contentType.includes('font/')) {
        filename += '.font'
      } else {
        filename += '.bin'
      }
    } else {
      filename += '.bin'
    }
  }

  const url = window.URL.createObjectURL(new Blob([response.data]))
  const link = document.createElement('a')
  link.href = url
  link.setAttribute('download', filename)
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  window.URL.revokeObjectURL(url)
}

// === –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ Content-Disposition ===
function getFilenameFromContentDisposition(contentDisposition: string | undefined): string | null {
  if (!contentDisposition) return null

  // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º filename* (RFC 5987, –ø–æ–¥–¥–µ—Ä–∂–∫–∞ Unicode)
  const encodedMatch = contentDisposition.match(/filename\*=UTF-8''(.+)/i)
  if (encodedMatch) {
    try {
      return decodeURIComponent(encodedMatch[1])
    } catch (e) {
      console.error('Failed to decode filename*:', e)
    }
  }

  // –ü–æ—Ç–æ–º –æ–±—ã—á–Ω—ã–π filename="..."
  const match = contentDisposition.match(/filename="?([^"]+)"?/i)
  if (match && match[1]) {
    return match[1]
  }

  return null
}

// –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ
export const sendScheduleInvite = async (candidateId: number, email: string): Promise<any> => {
  try {
    const response = await api.post('/schedule/invite', {
      candidate_id: candidateId,
      email: email,
    })
    return response.data
  } catch (error) {
    if (error instanceof AxiosError && error.response?.data) {
      try {
        const text = await error.response.data.text?.()
        if (text) error.response.data = text
      } catch {}
    }
    throw error
  }
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–∏–ø—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö —Ñ–∞–π–ª–∞—Ö
export type { ApiResponse, PaginatedResponse }
